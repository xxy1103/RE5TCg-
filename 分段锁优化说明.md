# DNS缓存分段锁优化说明

## 优化概述

我们将原有的单一LRU缓存升级为**分段式LRU缓存**，通过以下关键技术显著提升了多线程环境下的性能：

### 1. 核心改进

#### 分段锁架构
- **64个独立分段**：每个分段都有自己的读写锁和LRU链表
- **细粒度锁定**：线程只需锁定涉及的特定分段，而非整个缓存
- **并发度提升**：理论上可支持64个线程同时操作不同分段

#### 读写锁替代互斥锁
- **读操作并发**：多个线程可同时读取同一分段的数据
- **写者优先**：防止大量读请求导致写操作饥饿
- **跨平台支持**：Windows和POSIX系统都有优化实现

### 2. 数据结构变化

#### 原结构（单一LRU）
```c
typedef struct {
    dns_cache_entry_t* hash_table[DNS_CACHE_HASH_SIZE];
    dns_cache_entry_t* lru_head;        // 全局LRU头
    dns_cache_entry_t* lru_tail;        // 全局LRU尾
    // ... 需要全局锁保护所有操作
} dns_lru_cache_t;
```

#### 新结构（分段LRU）
```c
typedef struct {
    pthread_rwlock_t rwlock;            // 每段独立读写锁
    dns_cache_entry_t* lru_head;        // 该段的LRU头
    dns_cache_entry_t* lru_tail;        // 该段的LRU尾
    int current_size;                   // 该段当前大小
    int max_size;                       // 该段最大容量
} dns_cache_segment_t;

typedef struct {
    dns_cache_entry_t* hash_table[DNS_CACHE_HASH_SIZE];
    dns_cache_segment_t segments[DNS_CACHE_NUM_SEGMENTS];  // 64个分段
    pthread_mutex_t pool_lock;          // 仅保护内存池
    // ... 其他字段
} dns_lru_cache_t;
```

### 3. 性能提升机制

#### 锁竞争减少
- **原方案**：所有线程竞争1个全局锁
- **新方案**：平均每64个线程竞争1个分段锁

#### 读写分离
- **缓存查询（高频）**：使用读锁，允许并发
- **缓存更新（低频）**：使用写锁，互斥执行

#### 内存池优化
- **专用锁**：内存分配/释放使用单独的互斥锁
- **快速操作**：内存池操作时间短，锁持有时间最小

### 4. 关键函数说明

#### `get_cache_segment()`
```c
dns_cache_segment_t* get_cache_segment(dns_lru_cache_t* cache, const char* domain) {
    unsigned int hash = hash_domain(domain);
    // 位运算快速定位分段（要求分段数为2的幂）
    return &cache->segments[hash & (DNS_CACHE_NUM_SEGMENTS - 1)];
}
```

#### `dns_cache_get()` - 优化的查询
```c
// 1. 获取分段并申请读锁
dns_cache_segment_t* segment = get_cache_segment(cache, domain);
platform_rwlock_rdlock(&segment->rwlock);

// 2. 查找数据（多线程可并发进行）
// 3. 如果命中，升级为写锁更新LRU（保证一致性）
platform_rwlock_unlock(&segment->rwlock);
platform_rwlock_wrlock(&segment->rwlock);
lru_move_to_head_segment(segment, entry);
platform_rwlock_unlock(&segment->rwlock);
```

#### `dns_cache_put()` - 优化的插入
```c
// 1. 获取分段写锁
platform_rwlock_wrlock(&segment->rwlock);

// 2. 分段级别的淘汰（不影响其他分段）
if (segment->current_size >= segment->max_size) {
    evicted_entry = lru_remove_tail_segment(cache, segment);
}

// 3. 短暂释放分段锁，访问全局内存池
platform_rwlock_unlock(&segment->rwlock);
platform_mutex_lock(&cache->pool_lock);
// ... 内存池操作 ...
platform_mutex_unlock(&cache->pool_lock);

// 4. 重新获取分段锁，完成插入
platform_rwlock_wrlock(&segment->rwlock);
// ... 插入操作 ...
platform_rwlock_unlock(&segment->rwlock);
```

### 5. 使用方式

使用方式与原来完全相同，API未发生变化：

```c
// 初始化（内部自动创建64个分段）
dns_cache_init(&cache, 1000);

// 查询（自动路由到对应分段）
dns_cache_entry_t* entry = dns_cache_get(&cache, "example.com");

// 插入（自动路由到对应分段）
dns_cache_put(&cache, "example.com", response, 300);

// 统计（汇总所有分段数据）
dns_cache_print_stats(&cache);

// 清理（销毁所有分段锁）
dns_cache_destroy(&cache);
```

### 6. 预期性能提升

#### 理论分析
- **读操作**：支持64个线程完全并发（如果分布均匀）
- **写操作**：平均锁竞争降低至原来的1/64
- **混合负载**：在典型的"读多写少"场景下，性能提升最为显著

#### 适用场景
- **高并发DNS查询**：大量客户端同时查询不同域名
- **多线程服务器**：每个线程处理独立的请求
- **读写比例高**：缓存命中率高，更新频率相对较低

### 7. 注意事项

1. **分段数选择**：64是经验值，可根据CPU核心数和并发需求调整
2. **负载均衡**：哈希函数需要保证域名在各分段间均匀分布
3. **内存开销**：每个分段都有独立的锁和LRU结构，内存开销略有增加
4. **锁顺序**：严格按照分段锁→内存池锁的顺序，避免死锁

这个优化在保持API兼容性的同时，将缓存系统的并发能力提升了一个数量级，是现代高性能服务器架构的标准实践。
