#include "websocket/dnsServer.h"
#include <time.h>  // 添加时间相关的头文件支持

/*
 * ============================================================================
 * 全局变量声明
 * ============================================================================
 */

// 全局映射表：维护客户端请求ID与上游服务器响应ID的映射关系
// 这是实现并发处理的核心数据结构，确保响应能正确返回给对应的客户端
static dns_mapping_table_t g_mapping_table;

// 上游DNS套接字（全局，避免重复创建和销毁）
// 使用单个全局socket可以减少系统调用开销，提高性能
static SOCKET g_upstream_socket = INVALID_SOCKET;

/**
 * @brief 初始化映射表
 * 
 * 将映射表的所有条目清零，并设置初始状态。
 * 这个函数应该在服务器启动时调用一次。
 * 
 * @param table 指向要初始化的映射表的指针
 */
void init_mapping_table(dns_mapping_table_t* table) {
    memset(table, 0, sizeof(dns_mapping_table_t));
    table->next_id = 1;  // 从1开始分配ID，避免使用0（通常表示无效值）
    table->count = 0;    // 当前活跃映射数量为0
}

/**
 * @brief 添加新的映射关系
 * 
 * 为新的DNS请求创建ID映射关系。这个函数会：
 * 1. 先清理过期的映射条目以释放空间
 * 2. 查找空闲的映射表槽位
 * 3. 分配新的DNS Transaction ID
 * 4. 保存客户端信息和映射关系
 * 
 * @param table 映射表指针
 * @param original_id 客户端原始请求ID
 * @param client_addr 客户端地址信息
 * @param client_addr_len 客户端地址长度
 * @param new_id 输出参数，返回分配的新ID
 * @return int 成功返回MYSUCCESS，失败返回MYERROR
 */
int add_mapping(dns_mapping_table_t* table, unsigned short original_id, 
                struct sockaddr_in* client_addr, int client_addr_len, unsigned short* new_id) {
    // 清理过期映射，为新映射腾出空间
    cleanup_expired_mappings(table);
    
    // 遍历映射表，查找空闲槽位
    for (int i = 0; i < MAX_CONCURRENT_REQUESTS; i++) {
        if (!table->entries[i].is_active) {
            // 分配新ID，避免0（通常作为无效值）
            *new_id = table->next_id;
            if (table->next_id == 0) table->next_id = 1;  // 如果溢出到0，跳过并从1开始
            table->next_id++;
            
            // 填充映射信息 - 保存完整的客户端状态
            table->entries[i].original_id = original_id;        // 客户端原始ID
            table->entries[i].new_id = *new_id;                 // 服务器分配的新ID
            table->entries[i].client_addr = *client_addr;       // 客户端网络地址
            table->entries[i].client_addr_len = client_addr_len; // 地址结构长度
            table->entries[i].timestamp = time(NULL);           // 请求创建时间戳
            table->entries[i].is_active = 1;                    // 标记为活跃状态
            
            table->count++;  // 增加活跃映射计数
            log_debug("Added mapping: original_id=%d -> new_id=%d (slot %d, total: %d)", 
                     original_id, *new_id, i, table->count);
            return MYSUCCESS;
        }
    }
    
    // 映射表已满，无法添加新映射
    log_error("Mapping table is full (max: %d), cannot add new mapping", MAX_CONCURRENT_REQUESTS);
    return MYERROR;
}

/**
 * @brief 根据新ID查找映射
 * 
 * 当收到上游DNS服务器的响应时，使用响应中的Transaction ID
 * 来查找对应的映射条目，以确定原始客户端信息。
 * 
 * @param table 映射表指针
 * @param new_id 要查找的新ID（来自上游响应）
 * @return dns_mapping_entry_t* 找到的映射条目指针，未找到返回NULL
 */
dns_mapping_entry_t* find_mapping_by_new_id(dns_mapping_table_t* table, unsigned short new_id) {
    // 线性搜索映射表（考虑到表大小，这比哈希表更简单有效）
    for (int i = 0; i < MAX_CONCURRENT_REQUESTS; i++) {
        if (table->entries[i].is_active && table->entries[i].new_id == new_id) {
            log_debug("Found mapping for new_id=%d at slot %d", new_id, i);
            return &table->entries[i];
        }
    }
    
    // 未找到对应的映射，可能是：
    // 1. 响应ID错误
    // 2. 映射已过期被清理
    // 3. 收到了重复响应
    log_debug("No mapping found for new_id=%d", new_id);
    return NULL;
}

/**
 * @brief 移除映射
 * 
 * 当DNS请求完成（收到响应并转发给客户端）后，
 * 移除对应的映射条目以释放资源。
 * 
 * @param table 映射表指针
 * @param new_id 要移除的映射的新ID
 */
void remove_mapping(dns_mapping_table_t* table, unsigned short new_id) {
    // 查找并移除指定ID的映射
    for (int i = 0; i < MAX_CONCURRENT_REQUESTS; i++) {
        if (table->entries[i].is_active && table->entries[i].new_id == new_id) {
            // 标记为非活跃状态（实际上是删除）
            table->entries[i].is_active = 0;
            table->count--;  // 减少活跃映射计数
            log_debug("Removed mapping: new_id=%d from slot %d (remaining: %d)", 
                     new_id, i, table->count);
            return;
        }
    }
    
    // 如果执行到这里，说明没有找到要删除的映射
    log_warn("Attempted to remove non-existent mapping: new_id=%d", new_id);
}

/**
 * @brief 清理过期映射
 * 
 * 定期清理超时的DNS请求映射，防止：
 * 1. 内存泄漏（映射表条目一直被占用）
 * 2. 映射表满载（影响新请求处理）
 * 3. 无效映射积累（降低查找效率）
 * 
 * 判断过期的标准：当前时间 - 请求时间戳 > REQUEST_TIMEOUT
 * 
 * @param table 映射表指针
 */
void cleanup_expired_mappings(dns_mapping_table_t* table) {
    time_t current_time = time(NULL);  // 获取当前时间戳
    int cleaned = 0;  // 清理计数器
    
    // 遍历所有映射条目
    for (int i = 0; i < MAX_CONCURRENT_REQUESTS; i++) {
        if (table->entries[i].is_active && 
            (current_time - table->entries[i].timestamp) > REQUEST_TIMEOUT) {
            
            // 记录被清理的映射信息（用于调试）
            log_debug("Cleaning expired mapping: slot=%d, new_id=%d, age=%ld seconds", 
                     i, table->entries[i].new_id, 
                     (long)(current_time - table->entries[i].timestamp));
            
            // 标记为非活跃（删除）
            table->entries[i].is_active = 0;
            table->count--;  // 减少活跃映射计数
            cleaned++;       // 增加清理计数
        }
    }
    
    // 如果清理了映射，记录清理统计信息
    if (cleaned > 0) {
        log_info("Cleaned up %d expired mappings (timeout: %d seconds, remaining: %d)", 
                cleaned, REQUEST_TIMEOUT, table->count);
    }
}


/*
 * ============================================================================
 * 主服务器函数
 * ============================================================================
 */

/**
 * @brief DNS代理服务器主函数，使用非阻塞I/O处理并发请求
 * 
 * 这是DNS代理服务器的核心函数，实现了：
 * 1. 创建和配置服务器socket和上游socket
 * 2. 使用select()实现事件驱动的并发处理
 * 3. 分离处理客户端请求和上游响应
 * 4. 定期清理过期的映射关系
 * 
 * 架构特点：
 * - 单线程事件循环，避免线程同步复杂性
 * - 非阻塞I/O，提高并发性能
 * - ID映射机制，支持多客户端并发请求
 * 
 * @return int 成功返回 MYSUCCESS，失败返回 MYERROR
 */
int start_dns_proxy_server() {
    SOCKET server_socket; // 服务器套接字：监听客户端DNS请求
    struct sockaddr_in server_addr; // 服务器地址结构

    // === 第一步：初始化映射表 ===
    init_mapping_table(&g_mapping_table);
    log_info("Initialized DNS mapping table (max concurrent: %d)", MAX_CONCURRENT_REQUESTS);

    // === 第二步：创建服务器socket ===
    server_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (server_socket == INVALID_SOCKET) {
        log_error("Failed to create server socket: %d", WSAGetLastError());
        return MYERROR;
    }
    log_debug("Created server socket successfully");

    // === 第三步：设置服务器socket为非阻塞模式 ===
    // 非阻塞模式使得recvfrom()在没有数据时立即返回WSAEWOULDBLOCK
    // 而不是阻塞等待，这是实现并发处理的关键
    u_long mode = 1;
    if (ioctlsocket(server_socket, FIONBIO, &mode) == SOCKET_ERROR) {
        log_error("Failed to set server socket non-blocking mode: %d", WSAGetLastError());
        closesocket(server_socket);
        return MYERROR;
    }
    log_debug("Set server socket to non-blocking mode");

    // === 第四步：创建上游DNS socket ===
    g_upstream_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (g_upstream_socket == INVALID_SOCKET) {
        log_error("Failed to create upstream socket: %d", WSAGetLastError());
        closesocket(server_socket);
        return MYERROR;
    }
    log_debug("Created upstream socket successfully");

    // === 第五步：设置上游socket为非阻塞模式 ===
    if (ioctlsocket(g_upstream_socket, FIONBIO, &mode) == SOCKET_ERROR) {
        log_error("Failed to set upstream socket non-blocking: %d", WSAGetLastError());
        closesocket(server_socket);
        closesocket(g_upstream_socket);
        return MYERROR;
    }
    log_debug("Set upstream socket to non-blocking mode");

    // === 第六步：设置socket选项 ===
    // SO_REUSEADDR允许快速重启服务器，避免"Address already in use"错误
    int optval = 1;
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char *)&optval, sizeof(optval)) == SOCKET_ERROR) {
        log_warn("setsockopt(SO_REUSEADDR) failed with error: %d", WSAGetLastError());
        // 即使设置失败，也继续尝试绑定，因为这不一定是致命错误
    }

    // === 第七步：配置并绑定服务器地址 ===
    memset(&server_addr, 0, sizeof(server_addr)); // 清零结构体
    server_addr.sin_family = AF_INET;              // IPv4协议族
    server_addr.sin_addr.s_addr = INADDR_ANY;      // 监听所有网络接口
    server_addr.sin_port = htons(DNS_PORT);        // DNS标准端口53

    // 将套接字绑定到指定的IP地址和端口
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
        log_error("Failed to bind socket to port %d: %d", DNS_PORT, WSAGetLastError());
        closesocket(server_socket);
        closesocket(g_upstream_socket);
        return MYERROR;
    }

    log_info("DNS Proxy Server listening on port %d...", DNS_PORT);
    log_info("Ready to handle concurrent DNS requests (using select() event loop)");

    // === 第八步：主事件循环 ===    // === 第八步：主事件循环 ===
    /*
     * 这是一个经典的事件驱动循环，使用select()系统调用来：
     * 1. 同时监听多个socket的可读事件
     * 2. 避免忙等待（busy-waiting），节省CPU资源
     * 3. 在有事件时快速响应
     * 
     * 循环逻辑：
     * - 设置要监听的socket集合
     * - 调用select()等待事件（带超时）
     * - 根据返回的事件类型分别处理
     * - 定期执行维护任务（清理过期映射）
     */
    while (1) {
        fd_set read_fds;        // 可读文件描述符集合
        struct timeval timeout; // select()超时设置
        
        // === 准备监听的socket集合 ===
        FD_ZERO(&read_fds);                    // 清空文件描述符集合
        FD_SET(server_socket, &read_fds);      // 添加服务器socket（监听客户端请求）
        FD_SET(g_upstream_socket, &read_fds);  // 添加上游socket（监听上游响应）
        
        // === 设置select超时时间 ===
        // 1秒超时确保：
        // 1. 不会无限期阻塞
        // 2. 可以定期执行维护任务
        // 3. 响应外部中断信号
        timeout.tv_sec = 1;
        timeout.tv_usec = 0;
        
        // === 计算最大文件描述符值 ===
        // select()需要知道监听范围的上限
        SOCKET max_fd = (server_socket > g_upstream_socket) ? server_socket : g_upstream_socket;
        
        // === 调用select()等待事件 ===
        // 这是阻塞调用，直到：
        // 1. 有socket变为可读
        // 2. 达到超时时间
        // 3. 发生错误
        int activity = select(max_fd + 1, &read_fds, NULL, NULL, &timeout);
        
        // === 处理select()返回值 ===
        if (activity == SOCKET_ERROR) {
            log_error("select() failed: %d", WSAGetLastError());
            break; // 发生严重错误，退出主循环
        }
        
        // activity == 0 表示超时，继续下一次循环（会执行清理任务）
        // activity > 0 表示有socket事件，需要处理
        
        // === 处理客户端新请求 ===
        // 检查服务器socket是否有可读数据（新的客户端请求）
        if (FD_ISSET(server_socket, &read_fds)) {
            handle_client_requests(server_socket);
        }
        
        // === 处理上游服务器响应 ===
        // 检查上游socket是否有可读数据（上游DNS服务器的响应）
        if (FD_ISSET(g_upstream_socket, &read_fds)) {
            handle_upstream_responses(server_socket);
        }
        
        // === 定期维护任务 ===
        // 每10秒清理一次过期映射，避免：
        // 1. 内存泄漏
        // 2. 映射表满载
        // 3. 查找性能下降
        static time_t last_cleanup = 0;
        time_t current_time = time(NULL);
        if (current_time - last_cleanup > 10) {  // 清理间隔：10秒
            cleanup_expired_mappings(&g_mapping_table);
            last_cleanup = current_time;
            
            // 记录服务器状态（每10秒一次）
            log_debug("Server status: active mappings=%d, uptime=%ld seconds", 
                     g_mapping_table.count, current_time - last_cleanup + 10);
        }
    }

    // === 清理资源 ===
    // 正常情况下这里不会执行（无限循环），但为了代码完整性保留
    log_info("DNS Proxy Server shutting down...");
    closesocket(server_socket);
    closesocket(g_upstream_socket);
    return MYSUCCESS;
}


/*
 * ============================================================================
 * 传统DNS处理函数（向后兼容）
 * ============================================================================
 */

/**
 * @brief 处理接收到的DNS请求（传统同步方式）
 * 
 * 注意：这个函数保留用于向后兼容，但在新的并发架构中不再使用。
 * 新的架构使用handle_client_requests()和handle_upstream_responses()
 * 来分别处理客户端请求和上游响应，实现真正的并发处理。
 * 
 * 传统处理流程：请求->解析->转发->等待响应->解析响应->返回（同步阻塞）
 * 新的处理流程：请求->映射->转发 | 响应->查找映射->返回（异步非阻塞）
 * 
 * @param request_buffer 包含DNS请求数据的缓冲区
 * @param request_len 请求数据的长度
 * @param client_addr 指向客户端地址信息的指针
 * @param client_addr_len 客户端地址信息的长度
 * @param server_socket 服务器的套接字，用于向客户端发送响应
 * @return int 成功返回 MYSUCCESS，失败返回 MYERROR
 */
int handle_dns_request(char* request_buffer, int request_len, struct sockaddr_in* client_addr, int client_addr_len, SOCKET server_socket)
{
    char response_buffer[BUF_SIZE]; // 存储上游DNS服务器响应的缓冲区
    int response_len = 0; // 响应数据的长度
    clock_t start_time = clock(); // 记录函数开始执行的时间
    DNS_ENTITY* request_entity = parse_dns_packet(request_buffer, request_len);
    if (!request_entity) {
        log_error("Failed to parse DNS request");
        return MYERROR;
    }

    // 2. 打印接收请求的基本信息
    log_info("=== Received DNS Request ===");
    log_info("Transaction ID: %d", request_entity->id);
    log_info("Flags: 0x%04X", request_entity->flags);
    log_info("Questions: %d", request_entity->qdcount);
    // 遍历并打印所有问题
    if (request_entity->questions && request_entity->qdcount > 0) {
        for (int i = 0; i < request_entity->qdcount; i++) {
            DNS_QUESTION_ENTITY* question = &request_entity->questions[i];
            log_info("Question %d: Name=%s, Type=%d, Class=%d", 
                    i + 1, question->qname, question->qtype, question->qclass);
        }    }
    // 3. 将原始请求数据包转发给上游DNS服务器
    
    if (forward_to_upstream_dns(request_buffer, request_len, 
                               response_buffer, &response_len) != MYSUCCESS) {
        log_error("Failed to forward request to upstream DNS server");
        free_dns_entity(request_entity); // 释放请求实体内存
        return MYERROR;
    }

    // 4. 将从上游服务器收到的响应数据解析为 DNS_ENTITY 结构体
    DNS_ENTITY* response_entity = parse_dns_packet(response_buffer, response_len);
    if (!response_entity) {
        log_error("Failed to parse DNS response from upstream server");
        free_dns_entity(request_entity); // 释放请求实体内存
        return MYERROR;
    }

     // 5. 打印从上游DNS服务器收到的响应的关键信息
    log_info("=== Received DNS Response from Upstream ===");
    log_info("Transaction ID: %u", response_entity->id);
    log_info("Flags: 0x%04X", response_entity->flags);
    log_info("Questions: %d, Answers: %d", response_entity->qdcount, response_entity->ancount);

     // 遍历并打印所有答案记录
    if (response_entity->ancount > 0) {
        log_info("--- Answers ---");
        for (int i = 0; i < response_entity->ancount; i++) {
            R_DATA_ENTITY* answer = &response_entity->answers[i];
            
            // 根据记录类型格式化输出
            if (answer->type == A && answer->data_len == 4) { // A记录 (IPv4)
                unsigned char* ip_addr = (unsigned char*)answer->rdata;
                log_info("Answer %d: %s -> %d.%d.%d.%d (TTL: %lu)", 
                        i + 1, answer->name, ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3], 
                        (unsigned long)answer->ttl);
            } else if (answer->type == AAAA && answer->data_len == 16) { // AAAA记录 (IPv6)
                log_info("Answer %d: %s -> IPv6 (TTL: %lu)", i + 1, answer->name, (unsigned long)answer->ttl);
            } else if (answer->type == CNAME) { // CNAME记录
                log_info("Answer %d: %s -> CNAME: %s (TTL: %lu)", 
                        i + 1, answer->name, answer->rdata, (unsigned long)answer->ttl);
            } else { // 其他类型的记录
                log_info("Answer %d: %s -> Type %d (TTL: %lu)", 
                        i + 1, answer->name, answer->type, (unsigned long)answer->ttl);
            }
        }    }

    // 6. 将上游服务器的响应数据包发送回原始客户端   
    if (sendto(server_socket, response_buffer, response_len, 0, 
              (struct sockaddr*)client_addr, client_addr_len) == SOCKET_ERROR) {
        log_error("Failed to send DNS response to client: %d", WSAGetLastError());
        free_dns_entity(request_entity);
        free_dns_entity(response_entity);
        return MYERROR;
    }

    // 记录总执行时间
    double total_time = (double)(clock() - start_time) / CLOCKS_PER_SEC;
    log_info("DNS response sent to client %s:%d (%d bytes) - Total processing time: %.3f seconds", 
            inet_ntoa(client_addr->sin_addr), ntohs(client_addr->sin_port), response_len, total_time);

    // 清理本次请求/响应所分配的内存
    free_dns_entity(request_entity);
    free_dns_entity(response_entity);
    
    return MYSUCCESS;
}

/*
 * ============================================================================
 * 并发请求处理函数
 * ============================================================================
 */

/**
 * @brief 处理客户端请求
 * 
 * 这个函数处理来自客户端的DNS请求，实现了：
 * 1. 批量处理所有等待的请求（非阻塞接收）
 * 2. 为每个请求创建ID映射
 * 3. 修改请求ID避免冲突
 * 4. 转发请求到上游DNS服务器
 * 
 * 处理流程：
 * 客户端请求 -> 接收 -> 创建映射 -> 修改ID -> 转发上游
 * 
 * @param server_socket 服务器socket，用于接收客户端请求
 */
void handle_client_requests(SOCKET server_socket) {
    char request_buffer[BUF_SIZE];      // DNS请求数据缓冲区
    struct sockaddr_in client_addr;     // 客户端地址信息
    int client_addr_len = sizeof(client_addr);
    int request_len;                    // 接收到的请求长度
    int requests_processed = 0;         // 本次处理的请求计数
    
    // === 批量处理所有等待的客户端请求 ===
    /*
     * 使用while循环持续接收，直到没有更多数据。
     * 由于socket是非阻塞的，当没有数据时recvfrom()会立即返回WSAEWOULDBLOCK。
     * 这样可以在一次select()触发后处理所有排队的请求，提高效率。
     */
    while ((request_len = recvfrom(server_socket, request_buffer, BUF_SIZE, 0,
                                  (struct sockaddr*)&client_addr, &client_addr_len)) > 0) {
        
        requests_processed++;
        
        log_info("Received DNS request #%d from %s:%d (%d bytes)",
                requests_processed, inet_ntoa(client_addr.sin_addr), 
                ntohs(client_addr.sin_port), request_len);
        
        // === 验证请求数据完整性 ===
        if (request_len < 2) {
            log_warn("Request too short (%d bytes), ignoring", request_len);
            client_addr_len = sizeof(client_addr);  // 重置地址长度
            continue;
        }
        
        // === 提取并验证原始Transaction ID ===
        // DNS头部的前2个字节是Transaction ID（网络字节序）
        unsigned short original_id = ntohs(*(unsigned short*)request_buffer);
        unsigned short new_id;
        
        log_debug("Processing request with original_id=%d", original_id);
        
        // === 创建ID映射关系 ===
        /*
         * 为什么需要ID映射？
         * 1. 多个客户端可能使用相同的Transaction ID
         * 2. 我们需要确保每个上游请求都有唯一的ID
         * 3. 响应返回时要恢复原始ID给对应客户端
         */
        if (add_mapping(&g_mapping_table, original_id, &client_addr, client_addr_len, &new_id) != MYSUCCESS) {
            log_error("Failed to add mapping for request from %s:%d (original_id=%d)",
                     inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port), original_id);
            client_addr_len = sizeof(client_addr);  // 重置地址长度
            continue;
        }
        
        // === 修改请求的Transaction ID ===
        // 将客户端的原始ID替换为我们分配的新ID
        *(unsigned short*)request_buffer = htons(new_id);
        log_debug("Modified request ID: %d -> %d", original_id, new_id);
        
        // === 转发请求到上游DNS服务器 ===
        if (forward_request_to_upstream(request_buffer, request_len) != MYSUCCESS) {
            log_error("Failed to forward request to upstream (new_id=%d)", new_id);
            // 转发失败，清理刚创建的映射
            remove_mapping(&g_mapping_table, new_id);
        } else {
            log_debug("Successfully forwarded request with new_id=%d", new_id);
        }
        
        // === 重置地址长度供下次使用 ===
        client_addr_len = sizeof(client_addr);
    }
    
    // === 处理接收错误 ===
    /*
     * 当while循环退出时，检查是否是正常的"没有更多数据"，
     * 还是真正的网络错误。
     */
    int error = WSAGetLastError();
    if (error != WSAEWOULDBLOCK) {
        log_error("Error receiving from client: %d", error);
    } else if (requests_processed > 0) {
        log_debug("Processed %d client requests in this batch", requests_processed);
    }
}

/**
 * @brief 处理上游服务器响应
 * 
 * 这个函数处理来自上游DNS服务器的响应，实现了：
 * 1. 批量处理所有等待的响应（非阻塞接收）
 * 2. 根据响应ID查找对应的客户端映射
 * 3. 恢复原始Transaction ID
 * 4. 将响应转发回原始客户端
 * 5. 清理完成的映射关系
 * 
 * 处理流程：
 * 上游响应 -> 接收 -> 查找映射 -> 恢复原始ID -> 转发客户端 -> 清理映射
 * 
 * @param server_socket 服务器socket，用于向客户端发送响应
 */
void handle_upstream_responses(SOCKET server_socket) {
    char response_buffer[BUF_SIZE];     // DNS响应数据缓冲区
    struct sockaddr_in source_addr;     // 上游服务器地址（用于验证响应来源）
    int source_len = sizeof(source_addr);
    int response_len;                   // 接收到的响应长度
    int responses_processed = 0;        // 本次处理的响应计数
    
    // === 批量处理所有等待的上游响应 ===
    /*
     * 与处理客户端请求类似，批量处理所有等待的响应。
     * 这样可以减少select()调用次数，提高处理效率。
     */
    while ((response_len = recvfrom(g_upstream_socket, response_buffer, BUF_SIZE, 0,
                                   (struct sockaddr*)&source_addr, &source_len)) > 0) {
        
        responses_processed++;
        
        log_debug("Received DNS response #%d from upstream (%d bytes)", 
                 responses_processed, response_len);
        
        // === 验证响应数据完整性 ===
        if (response_len < 2) {
            log_warn("Response too short (%d bytes), ignoring", response_len);
            source_len = sizeof(source_addr);  // 重置地址长度
            continue;
        }
        
        // === 提取响应Transaction ID ===
        // 这是我们之前分配给上游请求的新ID
        unsigned short response_id = ntohs(*(unsigned short*)response_buffer);
        log_debug("Processing response with ID=%d", response_id);
        
        // === 查找对应的映射关系 ===
        /*
         * 根据响应ID查找原始客户端信息。
         * 如果找不到映射，可能的原因：
         * 1. 响应ID错误或损坏
         * 2. 映射已过期被清理
         * 3. 收到重复响应
         * 4. 恶意或错误的响应
         */
        dns_mapping_entry_t* mapping = find_mapping_by_new_id(&g_mapping_table, response_id);
        if (!mapping) {
            log_warn("No mapping found for response ID %d, discarding response", response_id);
            source_len = sizeof(source_addr);  // 重置地址长度
            continue;
        }
        
        // === 恢复原始Transaction ID ===
        /*
         * 将响应中的ID改回客户端原始的Transaction ID，
         * 这样客户端就能正确识别和处理响应。
         */
        unsigned short original_id = mapping->original_id;
        *(unsigned short*)response_buffer = htons(original_id);
        
        log_debug("Restored response ID: %d -> %d for client %s:%d", 
                 response_id, original_id,
                 inet_ntoa(mapping->client_addr.sin_addr), 
                 ntohs(mapping->client_addr.sin_port));
        
        // === 将响应发送给原始客户端 ===
        /*
         * 使用映射中保存的客户端地址信息，
         * 将响应准确发送回原始请求的客户端。
         */
        if (sendto(server_socket, response_buffer, response_len, 0,
                  (struct sockaddr*)&mapping->client_addr, mapping->client_addr_len) == SOCKET_ERROR) {
            int send_error = WSAGetLastError();
            log_error("Failed to send response to client %s:%d: %d",
                     inet_ntoa(mapping->client_addr.sin_addr), 
                     ntohs(mapping->client_addr.sin_port), send_error);
        } else {
            log_info("Response sent to client %s:%d (%d bytes, original_id=%d)",
                    inet_ntoa(mapping->client_addr.sin_addr), 
                    ntohs(mapping->client_addr.sin_port), response_len, original_id);
        }
        
        // === 清理完成的映射关系 ===
        /*
         * DNS请求-响应周期完成，清理映射以释放资源。
         * 这是关键步骤，防止映射表泄漏。
         */
        remove_mapping(&g_mapping_table, response_id);
        
        // === 重置地址长度供下次使用 ===
        source_len = sizeof(source_addr);
    }
    
    // === 处理接收错误 ===
    int error = WSAGetLastError();
    if (error != WSAEWOULDBLOCK) {
        log_error("Error receiving from upstream: %d", error);
    } else if (responses_processed > 0) {
        log_debug("Processed %d upstream responses in this batch", responses_processed);
    }
}

/**
 * @brief 转发请求到上游DNS服务器
 * 
 * 这个函数将经过ID修改的DNS请求发送到上游DNS服务器。
 * 使用全局的g_upstream_socket避免重复创建连接，提高性能。
 * 
 * 关键特点：
 * 1. 使用预先创建的全局socket
 * 2. 非阻塞发送（快速返回）
 * 3. 统一的错误处理
 * 4. 详细的日志记录
 * 
 * @param request_buffer 要转发的DNS请求数据
 * @param request_len 请求数据长度
 * @return int 成功返回MYSUCCESS，失败返回MYERROR
 */
int forward_request_to_upstream(char* request_buffer, int request_len) {
    struct sockaddr_in upstream_addr;  // 上游DNS服务器地址
    
    // === 配置上游DNS服务器地址 ===
    memset(&upstream_addr, 0, sizeof(upstream_addr));
    upstream_addr.sin_family = AF_INET;                        // IPv4
    upstream_addr.sin_port = htons(DNS_PORT);                  // DNS端口（53）
    upstream_addr.sin_addr.s_addr = inet_addr(DNS_SERVER);     // 上游DNS服务器IP
    
    // === 发送请求到上游服务器 ===
    /*
     * 使用全局的g_upstream_socket发送请求。
     * 由于socket是非阻塞的，sendto()会立即返回：
     * - 成功：数据已放入发送缓冲区
     * - WSAEWOULDBLOCK：发送缓冲区满，稍后重试
     * - 其他错误：网络问题或配置错误
     */
    if (sendto(g_upstream_socket, request_buffer, request_len, 0,
              (struct sockaddr*)&upstream_addr, sizeof(upstream_addr)) == SOCKET_ERROR) {
        
        int error = WSAGetLastError();
        
        // === 错误处理和分类 ===
        if (error == WSAEWOULDBLOCK) {
            // 发送缓冲区满，这在高负载时可能发生
            log_warn("Upstream send buffer full (WSAEWOULDBLOCK), request may be delayed");
            // 注意：在真实的生产环境中，这里可能需要重试逻辑
            return MYSUCCESS;  // 视为成功，因为数据最终会被发送
        } else {
            // 真正的网络错误
            log_error("Failed to send to upstream DNS (%s:%d): error %d", 
                     DNS_SERVER, DNS_PORT, error);
            return MYERROR;
        }
    }
    
    // === 记录成功发送 ===
    log_debug("Successfully sent %d bytes to upstream DNS server %s:%d", 
             request_len, DNS_SERVER, DNS_PORT);
    
    return MYSUCCESS;
}

// 转发请求到上游DNS服务器（传统同步版本）
/**
 * @brief 转发请求到上游DNS服务器（传统同步方式）
 * 
 * 注意：这是传统的同步版本，保留用于向后兼容。
 * 与新的forward_request_to_upstream()不同：
 * 1. 创建临时socket（每次请求都创建，效率较低）
 * 2. 同步等待响应（阻塞式）
 * 3. 设置接收超时（500ms）
 * 4. 处理完成后立即关闭socket
 * 
 * 新版本的优势：
 * - 使用全局socket，避免重复创建
 * - 非阻塞处理，支持并发
 * - 更好的错误处理和日志
 * 
 * @param request_buffer 请求数据缓冲区
 * @param request_len 请求数据长度
 * @param response_buffer 响应数据缓冲区
 * @param response_len 输出参数，返回响应数据长度
 * @return int 成功返回MYSUCCESS，失败返回MYERROR
 */
int forward_to_upstream_dns(char* request_buffer, int request_len, 
                           char* response_buffer, int* response_len) {
    SOCKET upstream_socket;             // 临时创建的上游socket
    struct sockaddr_in upstream_addr;   // 上游服务器地址
    int received_len;                   // 接收到的数据长度

    // === 创建临时socket连接到上游DNS服务器 ===
    upstream_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (upstream_socket == INVALID_SOCKET) {
        log_error("Failed to create temporary upstream socket: %d", WSAGetLastError());
        return MYERROR;
    }

    // === 设置接收超时为500毫秒 ===
    // 这是为了避免无限期等待响应，提高用户体验
    DWORD timeout_ms = 500;
    if (setsockopt(upstream_socket, SOL_SOCKET, SO_RCVTIMEO, 
                   (const char*)&timeout_ms, sizeof(timeout_ms)) == SOCKET_ERROR) {
        log_warn("Failed to set socket receive timeout: %d", WSAGetLastError());
        // 继续执行，不是致命错误
    }

    // === 设置上游DNS服务器地址 ===
    memset(&upstream_addr, 0, sizeof(upstream_addr));
    upstream_addr.sin_family = AF_INET;
    upstream_addr.sin_port = htons(DNS_PORT);
    upstream_addr.sin_addr.s_addr = inet_addr(DNS_SERVER);

    // === 发送请求到上游DNS服务器 ===
    if (sendto(upstream_socket, request_buffer, request_len, 0, 
              (struct sockaddr*)&upstream_addr, sizeof(upstream_addr)) == SOCKET_ERROR) {
        log_error("Failed to send request to upstream DNS server: %d", WSAGetLastError());
        closesocket(upstream_socket);
        return MYERROR;
    }

    log_info("Request forwarded to upstream DNS server %s:%d", DNS_SERVER, DNS_PORT);

    // === 同步等待响应 ===
    struct sockaddr_in source_addr;
    int source_len = sizeof(source_addr);
    received_len = recvfrom(upstream_socket, response_buffer, BUF_SIZE, 0, 
                           (struct sockaddr*)&source_addr, &source_len);
    
    // === 处理接收结果 ===
    if (received_len == SOCKET_ERROR) {
        int error_code = WSAGetLastError();
        if (error_code == WSAETIMEDOUT) {
            log_warn("Timeout waiting for response from upstream DNS server (500ms)");
        } else if (error_code == WSAECONNRESET) {
            log_warn("Connection reset by upstream DNS server");
        } else {
            log_error("Failed to receive response from upstream DNS server: %d", error_code);
        }
        closesocket(upstream_socket);
        return MYERROR;
    }

    *response_len = received_len;
    log_info("Received response from upstream DNS server (%d bytes)", received_len);

    // === 清理临时socket ===
    closesocket(upstream_socket);
    return MYSUCCESS;
}